
RSA加密算法是一种非对称加密算法，在公开密钥加密和电子商业中被广泛使用。RSA是由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）在1977年一起提出的。当时他们三人都在麻省理工学院工作。RSA 就是他们三人姓氏开头字母拼在一起组成的。[1]

1973年，在英国政府通讯总部工作的数学家克利福德·柯克斯（Clifford Cocks）在一个内部文件中提出了一个与之等效的算法，但该算法被列入机密，直到1997年才得到公开。[2]

对极大整数做因数分解的难度决定了 RSA 算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的 RSA 钥匙才可能被强力方式破解。到2020年为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被破解的。

1983年9月12日麻省理工学院在美国为RSA算法申请了专利。[3]这个专利于2000年9月21日失效。[4]由于该算法在申请专利前就已经被发表了[5]，在世界上大多数其它地区这个专利权不被承认。

# 操作
## 公钥与私钥的产生
假设爱丽丝想要通过一个不可靠的媒体接收鲍伯的一条私人信息。她可以用以下的方式来产生一个公钥和一个私钥：

1. 随意选择两个大的素数 $p$ 和 $q$，$p$ 不等于 $q$ ，计算 $N=pq$。
2. 根据欧拉函数(之积)，求得
$$
{\displaystyle r=\varphi (N)=\varphi (p)\times \varphi (q)=(p-1)(q-1)}
$$
3. 选择一个小于 $r$ 的整数 $e$ ，使 $e$ 与 $r$ 互质。并求得 $e$ 关于$r$的模逆元，命名为 $d$ （求 $d$ 令
$$
ed\equiv 1{\pmod {r}}
$$
。（模逆元存在，当且仅当 $e$ 与 $r$ 互质）

4. 将 $p$ 和 $q$ 的记录销毁。

${(N,e)}$是公钥，${(N,d)}$是私钥。爱丽丝将她的公钥${(N,e)}$传给鲍伯，而将她的私钥${(N,d)}$藏起来。

## 加密消息
假设鲍伯想给爱丽丝送一个消息 $m$，他知道爱丽丝产生的 $N$ 和 $e$。他使用起先与爱丽丝约好的格式将 $m$ 转换为一个小于 $N$ 的非负整数 $n$，比如他可以将每一个字转换为这个字的Unicode码，然后将这些数字连在一起组成一个数字。假如他的信息非常长的话，他可以将这个信息分为几段，然后将每一段转换为 $n$。用下面这个公式他可以将 $n$ 加密为 $c$：
$$
c=n^{e}{\bmod {N}}
$$

计算 c 并不复杂。鲍伯算出 c 后就可以将它传递给爱丽丝。

## 解密消息
爱丽丝得到鲍伯的消息 $c$ 后就可以利用她的密钥 $d$ 来解码。她可以用以下这个公式来将 $c$ 转换为 $n$：
$$
n=c^{d}{\bmod {N}}
$$
得到 $n$ 后，她可以将原来的信息 $m$ 重新复原。

解码的原理是
$$
c^d \equiv n^{e \cdot d}\ (\mathrm{mod}\ N)
$$
已知 ${\displaystyle ed\equiv 1{\pmod {r}}}$，即 ${\displaystyle ed=1+h\varphi (N)}$。那么有
$$
n^{ed}=n^{1+h\varphi (N)}=n\cdot n^{h\varphi (N)}=n\left(n^{\varphi (N)}\right)^{h}
$$
若n与N互素，则由欧拉定理得：
$$
n^{ed}\equiv n\left(n^{\varphi (N)}\right)^{h}\equiv n(1)^{h}\equiv n{\pmod {N}}
$$
若n与N不互素，则不失一般性考虑 $n=ph$，以及 $ed-1=k(q-1)$，得：
$$
n^{ed}=(ph)^{ed}\equiv 0\equiv ph\equiv n{\pmod {p}}
$$

$$
n^{ed}=n^{ed-1}n=n^{k(q-1)}n=(n^{q-1})^{k}n\equiv 1^{k}n\equiv n{\pmod {q}}
$$
故 $n^{ed}\equiv n{\pmod {N}}$ 得证。

## 签名消息
RSA也可以用来为一个消息署名。假如爱丽丝想给鲍伯传递一个署名的消息的话，那么她可以为她的消息计算一个散列值（Message digest），然后用她的私钥“加密”（如同前面“加密消息”的步骤）这个散列值并将这个“署名”加在消息的后面。这个消息只有用她的公钥才能被解密。鲍伯获得这个消息后可以用爱丽丝的公钥“解密”（如同前面“解密消息”的步骤）这个散列值，然后将这个数据与他自己为这个消息计算的散列值相比较。假如两者相符的话，那么鲍伯就可以知道发信人持有爱丽丝的私钥，以及这个消息在传播路径上没有被篡改过。






# 参考资料
* [RSA加密算法](https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95)




